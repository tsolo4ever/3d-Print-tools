/* ============================================
   TH3D Multi-File Configuration Parser
   Parse TH3D Unified Firmware Configuration files
   Loads multiple mapping files for complete coverage
   
   Supports parsing:
   - Configuration.h (basic settings)
   - Configuration_adv.h (advanced features - 4 parts)
   - Configuration_backend.h (backend logic)
   - Configuration_speed.h (motion profiles)
   
   ‚ö†Ô∏è KNOWN LIMITATIONS:
   - Array fields (DEFAULT_AXIS_STEPS_PER_UNIT) need special handling
   - Field mapping has stepsPerMM.x, stepsPerMM.y, etc. as separate fields
   - But #define is a single array { 80, 80, 400, 93 }
   
   üìã TODO:
   - Add array index extraction logic in storeValue()
   - Handle nested array-to-object mapping (array[0] ‚Üí obj.x)
   - Test with all TH3D example files
   ============================================ */

const TH3DConfigParser = {
    
    // Field mappings loaded from multiple JSON files
    fieldMapping: null,
    
    // Mapping file paths
    mappingFiles: [
        'assets/data/maps/th3d/th3d-config-mapping.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part1.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part2.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part3.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part4.json',
        'assets/data/maps/th3d/th3d-config-backend-mapping.json',
        'assets/data/maps/th3d/th3d-config-speed-mapping.json'
    ],
    
    /**
     * Load and merge all field mapping files
     */
    async loadFieldMapping() {
        if (this.fieldMapping) return this.fieldMapping;
        
        try {
            console.log('üìÇ Loading', this.mappingFiles.length, 'TH3D mapping files...');
            
            // Load all mapping files in parallel
            const promises = this.mappingFiles.map(path => 
                fetch(path).then(r => r.json())
            );
            
            const mappings = await Promise.all(promises);
            
            // Merge all mappings into one object
            this.fieldMapping = this.mergeMappings(mappings);
            
            console.log('‚úÖ TH3D Field Mappings loaded and merged');
            console.log('   Categories:', Object.keys(this.fieldMapping).filter(k => !k.startsWith('$') && k !== 'description' && k !== 'lastUpdated' && k !== 'version').join(', '));
            
            return this.fieldMapping;
        } catch (error) {
            console.error('‚ùå Failed to load field mappings:', error);
            throw new Error('Could not load TH3D field mapping files from assets/data/maps/th3d/');
        }
    },
    
    /**
     * Merge multiple mapping files into one
     * Later files override earlier files for the same fields
     */
    mergeMappings(mappings) {
        const merged = {
            $schema: 'TH3D Configuration Field Mapping - Merged',
            version: '2.0.0',
            description: 'Merged from multiple mapping files'
        };
        
        // Merge each mapping file
        for (const mapping of mappings) {
            for (const [category, fields] of Object.entries(mapping)) {
                // Skip metadata
                if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'part' || category === 'sourceFile' || category === 'th3dNotes') {
                    continue;
                }
                
                // Initialize category if it doesn't exist
                if (!merged[category]) {
                    merged[category] = {};
                }
                
                // Merge fields (later files override earlier)
                Object.assign(merged[category], fields);
            }
        }
        
        return merged;
    },
    
    /**
     * Parse TH3D Configuration.h file content
     * @param {string} content - File content as text
     * @returns {object} Parsed configuration object
     */
    async parseConfigFile(content) {
        // Ensure mapping is loaded
        await this.loadFieldMapping();
        
        const config = {
            basic: {},
            hardware: {},
            temperature: {},
            motion: {},
            probe: {},
            bedLeveling: {},
            advanced: {},
            safety: {},
            warnings: []
        };
        
        // Store defined variables for substitution (preserve across multiple file parses)
        if (!this.variables) {
            this.variables = {};
        }
        
        const lines = content.split('\n');
        
        console.log('üîç TH3D Parser (Data-Driven): Starting parse of', lines.length, 'lines');
        
        // First pass: collect simple variable definitions
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith('#define')) {
                const match = line.match(/#define\s+(\w+)\s+([\d.]+)$/);
                if (match) {
                    this.variables[match[1]] = match[2];
                    console.log('   üìù Stored variable:', match[1], '=', match[2]);
                }
            }
        }
        
        console.log('üîç Variables collected:', Object.keys(this.variables).length);
        
        // Second pass: parse using field mapping
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines and pure comments
            if (!line || line.startsWith('//') || line.startsWith('/*') || line.startsWith('*')) {
                continue;
            }
            
            // Parse #define statements
            if (line.startsWith('#define')) {
                this.parseDefineLine(line, config);
            }
        }
        
        console.log('üîç Final bedLeveling config:', config.bedLeveling);
        
        // Validate and add warnings
        this.validateConfig(config);
        
        return config;
    },
    
    /**
     * Parse a single #define line using field mapping
     * 
     * ‚ö†Ô∏è TODO: Add fallback for unmapped fields
     * If a #define is not found in the mapping, we silently skip it.
     * Consider adding a "unknown" or "unmapped" section to capture these
     * so users can identify missing fields in the mapping.
     */
    parseDefineLine(line, config) {
        // Extract the define name and value
        const match = line.match(/#define\s+(\w+)(?:\s+(.+))?/);
        if (!match) return;
        
        const [, defineName, value] = match;
        const cleanValue = value ? value.split('//')[0].trim() : true;
        
        // Search through field mapping for this define
        for (const [category, fields] of Object.entries(this.fieldMapping)) {
            // Skip metadata fields
            if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'warnings') {
                continue;
            }
            
            for (const [fieldName, fieldSpec] of Object.entries(fields)) {
                // Skip non-field entries
                if (typeof fieldSpec !== 'object' || !fieldSpec.mapsFrom) {
                    continue;
                }
                
                // Check if this define matches any mapsFrom value
                const mapsFrom = Array.isArray(fieldSpec.mapsFrom) ? fieldSpec.mapsFrom : [fieldSpec.mapsFrom];
                
                // Handle wildcard matches (e.g., "LCD_*", "DISPLAY_*")
                let matched = false;
                for (const mapPattern of mapsFrom) {
                    if (mapPattern.includes('*')) {
                        // Wildcard pattern - convert to regex
                        const regex = new RegExp('^' + mapPattern.replace(/\*/g, '.*') + '$');
                        if (regex.test(defineName)) {
                            matched = true;
                            break;
                        }
                    } else if (mapPattern === defineName) {
                        // Exact match
                        matched = true;
                        break;
                    }
                }
                
                if (matched) {
                    // Extract and store the value based on field type
                    const extractedValue = this.extractValue(cleanValue, fieldSpec.type, fieldSpec);
                    
                    // Store in correct category and handle nested structures
                    this.storeValue(config, category, fieldName, extractedValue, fieldSpec);
                    
                    console.log(`   ‚úÖ Mapped ${defineName} ‚Üí ${category}.${fieldName} =`, extractedValue);
                    return; // Stop after first match
                }
            }
        }
        
        // TODO: If we reach here, the define was not found in mapping
        // Consider logging or storing unknown defines for debugging
        // console.log(`   ‚ö†Ô∏è Unmapped define: ${defineName} = ${cleanValue}`);
    },
    
    /**
     * Extract value based on field type
     * Handles variable substitution - returns expressions as-is
     */
    extractValue(rawValue, type, fieldSpec) {
        // Ensure rawValue is a string for processing
        if (typeof rawValue !== 'string') {
            rawValue = String(rawValue);
        }
        
        // Check if rawValue is a variable reference (not a number, not quoted, not an array, not an expression)
        if (!rawValue.match(/^[\d.-]+$/) &&      // Not a simple number
            !rawValue.match(/^["']/) &&           // Not a quoted string
            !rawValue.match(/^\{/) &&             // Not an array
            !rawValue.match(/[\(\)\*\/\+\-]/) && // Not a mathematical expression
            this.variables && this.variables[rawValue]) {
            
            console.log(`üîÑ TH3D Parser: Resolving variable ${rawValue} = ${this.variables[rawValue]}`);
            rawValue = this.variables[rawValue];
        }
        
        // For expressions like (200*60), store as-is for user configuration
        if (rawValue.match(/[\(\)\*\/]/)) {
            console.log(`üìê TH3D Parser: Storing expression as-is: ${rawValue}`);
            return rawValue; // Return the expression string for user to configure
        }
        
        switch (type) {
            case 'string':
                return this.extractString(rawValue);
            
            case 'integer':
                const intVal = parseInt(rawValue);
                return isNaN(intVal) ? rawValue : intVal; // Return original if can't parse
            
            case 'float':
                const floatVal = parseFloat(rawValue);
                return isNaN(floatVal) ? rawValue : floatVal; // Return original if can't parse
            
            case 'boolean':
                // For defines, presence = true
                return rawValue === true || rawValue === 'true' || rawValue === '1';
            
            case 'array':
                return this.extractArray(rawValue);
            
            default:
                // Unknown type, return as-is
                return rawValue;
        }
    },
    
    /**
     * Store value in config object (handles nested structures and array mapping)
     * 
     * ‚úÖ FIXED: Now handles array field mapping
     * When mapsFrom contains array notation like "DEFAULT_AXIS_STEPS_PER_UNIT[0]",
     * the parser extracts the array once and maps elements to individual fields:
     *   - array[0] ‚Üí stepsPerMM.x
     *   - array[1] ‚Üí stepsPerMM.y
     *   - array[2] ‚Üí stepsPerMM.z
     *   - array[3] ‚Üí stepsPerMM.e
     */
    storeValue(config, category, fieldName, value, fieldSpec) {
        // Handle array index extraction for fields like DEFAULT_AXIS_STEPS_PER_UNIT[0]
        const mapsFrom = Array.isArray(fieldSpec.mapsFrom) ? fieldSpec.mapsFrom[0] : fieldSpec.mapsFrom;
        const arrayMatch = mapsFrom.match(/^(.+)\[(\d+)\]$/);
        
        if (arrayMatch && Array.isArray(value)) {
            // This is an array field with index notation
            const [, arrayName, indexStr] = arrayMatch;
            const index = parseInt(indexStr);
            
            console.log(`   üî¢ Array field detected: ${arrayName}[${index}] ‚Üí extracting element ${index}`);
            
            // Extract the specific array element
            value = value[index];
            
            // Convert to appropriate type
            if (fieldSpec.type === 'float') {
                value = parseFloat(value);
            } else if (fieldSpec.type === 'integer') {
                value = parseInt(value);
            }
        }
        
        // Handle nested field names (e.g., "motion.stepsPerMM.x")
        if (fieldName.includes('.')) {
            const parts = fieldName.split('.');
            let current = config[category];
            
            for (let i = 0; i < parts.length - 1; i++) {
                if (!current[parts[i]]) {
                    current[parts[i]] = {};
                }
                current = current[parts[i]];
            }
            
            current[parts[parts.length - 1]] = value;
        } else {
            // Simple field
            if (!config[category]) {
                config[category] = {};
            }
            config[category][fieldName] = value;
        }
        
        // Special handling for specific fields
        
        // Store USER_PRINTER_NAME for variable resolution
        if (fieldName === 'machineName' && category === 'basic') {
            config.basic.userPrinterNameValue = value;
        }
        
        // Handle EZABL_POINTS variable storage
        if (fieldName === 'gridPointsX' && value && !isNaN(value)) {
            this.variables['EZABL_POINTS'] = value;
        }
    },
    
    /**
     * Extract string value from quotes
     */
    extractString(value) {
        const match = value.match(/["'](.+?)["']/);
        return match ? match[1] : value;
    },
    
    /**
     * Extract array values from { x, y, z, ... }
     * Handles variable substitution (e.g., CUSTOM_ESTEPS_VALUE)
     */
    extractArray(value) {
        const match = value.match(/\{(.+?)\}/);
        if (!match) return [];
        return match[1].split(',').map(v => {
            v = v.trim();
            // Check if it's a variable reference
            if (this.variables && this.variables[v]) {
                console.log(`üîÑ TH3D Parser: Substituting ${v} = ${this.variables[v]}`);
                return this.variables[v];
            }
            return v;
        });
    },
    
    /**
     * Validate configuration and add warnings
     */
    validateConfig(config) {
        // Use validation rules from field mapping
        for (const [category, fields] of Object.entries(this.fieldMapping)) {
            // Skip metadata
            if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'warnings') {
                continue;
            }
            
            for (const [fieldName, fieldSpec] of Object.entries(fields)) {
                if (!fieldSpec.validation) continue;
                
                const validation = fieldSpec.validation;
                const value = config[category]?.[fieldName];
                
                // Required field check
                if (fieldSpec.required && !value) {
                    config.warnings.push({
                        level: validation.errorLevel || 'error',
                        message: `Missing required field: ${fieldName} (${fieldSpec.mapsFrom.join(', ')})`
                    });
                }
                
                // Must be true check
                if (validation.mustBeTrue && !value) {
                    config.warnings.push({
                        level: validation.errorLevel || 'error',
                        message: fieldSpec.th3dNotes || `${fieldName} should be enabled for safety`
                    });
                }
                
                // Range checks
                if (value !== undefined && value !== null) {
                    if (validation.min !== undefined && value < validation.min) {
                        config.warnings.push({
                            level: 'warning',
                            message: `${fieldName} (${value}) is below minimum (${validation.min})`
                        });
                    }
                    
                    if (validation.max !== undefined && value > validation.max) {
                        config.warnings.push({
                            level: 'warning',
                            message: `${fieldName} (${value}) is above maximum (${validation.max})`
                        });
                    }
                    
                    // Warning if outside range
                    if (validation.warningIfOutside) {
                        if ((validation.min && value < validation.min) || (validation.max && value > validation.max)) {
                            config.warnings.push({
                                level: 'warning',
                                message: `${fieldName} (${value}) is outside typical range (${validation.min}-${validation.max})`
                            });
                        }
                    }
                }
            }
        }
    },
    
    /**
     * Parse multiple TH3D configuration files and merge into one config
     * @param {object} files - Object with file contents: { config: "", configAdv: "", configBackend: "", configSpeed: "" }
     * @returns {object} Merged parsed configuration object
     */
    async parseMultipleFiles(files) {
        // Ensure mapping is loaded
        await this.loadFieldMapping();
        
        console.log('üìö TH3D Parser: Parsing multiple config files');
        
        // Parse each file in order (later files can reference earlier variables)
        const configs = [];
        
        if (files.config) {
            console.log('   üìÑ Parsing Configuration.h...');
            const cfg = await this.parseConfigFile(files.config);
            configs.push(cfg);
        }
        
        if (files.configAdv) {
            console.log('   üìÑ Parsing Configuration_adv.h...');
            const cfg = await this.parseConfigFile(files.configAdv);
            configs.push(cfg);
        }
        
        if (files.configBackend) {
            console.log('   üìÑ Parsing Configuration_backend.h...');
            const cfg = await this.parseConfigFile(files.configBackend);
            configs.push(cfg);
        }
        
        if (files.configSpeed) {
            console.log('   üìÑ Parsing Configuration_speed.h...');
            const cfg = await this.parseConfigFile(files.configSpeed);
            configs.push(cfg);
        }
        
        // Merge all configs (later files override earlier)
        const merged = this.mergeConfigs(configs);
        
        console.log('‚úÖ TH3D Parser: All files parsed and merged');
        
        return merged;
    },
    
    /**
     * Merge multiple config objects
     * Later configs override earlier ones for the same fields
     */
    mergeConfigs(configs) {
        const merged = {
            basic: {},
            hardware: {},
            temperature: {},
            motion: {},
            probe: {},
            bedLeveling: {},
            advanced: {},
            safety: {},
            communication: {},
            serial: {},
            tmc: {},
            thermal: {},
            lcd: {},
            speed: {},
            backend: {},
            warnings: []
        };
        
        // Merge each config
        for (const config of configs) {
            for (const [category, fields] of Object.entries(config)) {
                if (category === 'warnings') {
                    // Accumulate warnings from all files
                    merged.warnings.push(...fields);
                    continue;
                }
                
                // Initialize category if needed
                if (!merged[category]) {
                    merged[category] = {};
                }
                
                // Merge fields (deep merge for nested objects)
                this.deepMerge(merged[category], fields);
            }
        }
        
        return merged;
    },
    
    /**
     * Deep merge two objects (later values override earlier)
     */
    deepMerge(target, source) {
        for (const [key, value] of Object.entries(source)) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                // Nested object - recurse
                if (!target[key]) {
                    target[key] = {};
                }
                this.deepMerge(target[key], value);
            } else {
                // Simple value or array - override
                target[key] = value;
            }
        }
    },
    
    /**
     * Alias for parseConfigFile (for compatibility)
     */
    async parseConfigurationH(content) {
        return await this.parseConfigFile(content);
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.TH3DConfigParser = TH3DConfigParser;
}
