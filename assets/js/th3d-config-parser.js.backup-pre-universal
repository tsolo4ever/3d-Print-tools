/* ============================================
   TH3D Multi-File Configuration Parser
   Parse TH3D Unified Firmware Configuration files
   Loads multiple mapping files for complete coverage
   
   Supports parsing:
   - Configuration.h (basic settings)
   - Configuration_adv.h (advanced features - 4 parts)
   - Configuration_backend.h (backend logic)
   - Configuration_speed.h (motion profiles)
   
   ‚ö†Ô∏è KNOWN LIMITATIONS:
   - Array fields (DEFAULT_AXIS_STEPS_PER_UNIT) need special handling
   - Field mapping has stepsPerMM.x, stepsPerMM.y, etc. as separate fields
   - But #define is a single array { 80, 80, 400, 93 }
   
   üìã TODO:
   - Add array index extraction logic in storeValue()
   - Handle nested array-to-object mapping (array[0] ‚Üí obj.x)
   - Test with all TH3D example files
   ============================================ */

const TH3DConfigParser = {
    
    // Debug mode - set to false to suppress all console logging
    DEBUG: true,
    
    /**
     * Debug logger - only logs if DEBUG is true
     * @param {...any} args - Arguments to log
     */
    log(...args) {
        if (this.DEBUG) {
            console.log(...args);
        }
    },
    
    // Field mappings loaded from multiple JSON files
    fieldMapping: null,
    
    // Mapping file paths
    mappingFiles: [
        'assets/data/maps/th3d/th3d-config-mapping.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part1.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part2.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part3.json',
        'assets/data/maps/th3d/th3d-config-adv-mapping-part4.json',
        'assets/data/maps/th3d/th3d-config-backend-mapping.json',
        'assets/data/maps/th3d/th3d-config-speed-mapping.json'
    ],
    
    /**
     * Load and merge all field mapping files
     */
    async loadFieldMapping() {
        if (this.fieldMapping) return this.fieldMapping;
        
        try {
            this.log('üìÇ Loading', this.mappingFiles.length, 'TH3D mapping files...');
            
            // Load all mapping files in parallel
            const promises = this.mappingFiles.map(path => 
                fetch(path).then(r => r.json())
            );
            
            const mappings = await Promise.all(promises);
            
            // Merge all mappings into one object
            this.fieldMapping = this.mergeMappings(mappings);
            
            this.log('‚úÖ TH3D Field Mappings loaded and merged');
            this.log('   Categories:', Object.keys(this.fieldMapping).filter(k => !k.startsWith('$') && k !== 'description' && k !== 'lastUpdated' && k !== 'version').join(', '));
            
            return this.fieldMapping;
        } catch (error) {
            console.error('‚ùå Failed to load field mappings:', error);
            throw new Error('Could not load TH3D field mapping files from assets/data/maps/th3d/');
        }
    },
    
    /**
     * Merge multiple mapping files into one
     * Later files override earlier files for the same fields
     */
    mergeMappings(mappings) {
        const merged = {
            $schema: 'TH3D Configuration Field Mapping - Merged',
            version: '2.0.0',
            description: 'Merged from multiple mapping files'
        };
        
        // Merge each mapping file
        for (const mapping of mappings) {
            for (const [category, fields] of Object.entries(mapping)) {
                // Skip metadata
                if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'part' || category === 'sourceFile' || category === 'th3dNotes') {
                    continue;
                }
                
                // Initialize category if it doesn't exist
                if (!merged[category]) {
                    merged[category] = {};
                }
                
                // Merge fields (later files override earlier)
                Object.assign(merged[category], fields);
            }
        }
        
        return merged;
    },
    
    /**
     * Parse TH3D Configuration.h file content
     * @param {string} content - File content as text
     * @returns {object} Parsed configuration object
     */
    async parseConfigFile(content) {
        // Ensure mapping is loaded
        await this.loadFieldMapping();
        
        const config = {
            basic: {},
            hardware: {},
            temperature: {},
            motion: {},
            probe: {},
            bedLeveling: {},
            advanced: {},
            safety: {},
            warnings: []
        };
        
        // Store defined variables for substitution (preserve across multiple file parses)
        if (!this.variables) {
            this.variables = {};
        }
        
        // Track global conditionals (persist across all files)
        if (!this.globalConditionals) {
            this.globalConditionals = new Set();
        }
        
        const lines = content.split('\n');
        
        this.log('üîç TH3D Parser (Data-Driven): Starting parse of', lines.length, 'lines');
        
        // First pass: collect global conditionals (printer models, major features)
        // These stay active for all 4 config files
        // NOTE: Only collect simple defines, NOT ones inside conditional blocks
        this.log('üéØ Pass 1: Detecting global conditionals...');
        let inConditionalBlock = false;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip comments - only track active #defines
            if (line.startsWith('//')) continue;
            
            // Track conditional block boundaries
            if (line.startsWith('#if') || line.startsWith('#ifndef') || line.startsWith('#ifdef')) {
                inConditionalBlock = true;
                continue;
            }
            if (line.startsWith('#endif')) {
                inConditionalBlock = false;
                continue;
            }
            
            // Only process defines outside conditional blocks in pass 1
            if (!inConditionalBlock && line.startsWith('#define')) {
                const match = line.match(/#define\s+(\w+)/);
                if (match) {
                    const defineName = match[1];
                    
                    // Track global conditionals (printer models, features, etc.)
                    if (this.isGlobalConditional(defineName)) {
                        this.globalConditionals.add(defineName);
                        this.log('   ‚úÖ Global conditional active:', defineName);
                    }
                    
                    // Store unconditional numeric variables for substitution
                    const valueMatch = line.match(/#define\s+(\w+)\s+([\d.]+)$/);
                    if (valueMatch) {
                        this.variables[valueMatch[1]] = valueMatch[2];
                        this.log('   üì¶ Variable stored:', valueMatch[1], '=', valueMatch[2]);
                    }
                }
            }
        }
        
        this.log('üéØ Active conditionals:', Array.from(this.globalConditionals).join(', '));
        this.log('üîç Variables collected:', Object.keys(this.variables).length);
        
        // Second pass: parse using field mapping with conditional checks
        this.log('üìù Pass 2: Parsing fields...');
        
        // Track conditional block state
        let conditionalStack = [];
        let skipUntilEndif = 0;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines and pure comments
            if (!line || line.startsWith('//') || line.startsWith('/*') || line.startsWith('*')) {
                continue;
            }
            
            // Handle #ifndef - typically guards against redefinition
            if (line.startsWith('#ifndef')) {
                const match = line.match(/#ifndef\s+(\w+)/);
                if (match) {
                    const defineName = match[1];
                    const isDefined = this.variables[defineName] !== undefined || config.basic[defineName] !== undefined;
                    conditionalStack.push({ type: 'ifndef', condition: !isDefined, taken: false });
                    if (isDefined) {
                        skipUntilEndif++;
                        this.log(`   ‚è≠Ô∏è  Skipping #ifndef ${defineName} block (already defined)`);
                    }
                }
                continue;
            }
            
            // Handle #if - evaluate condition
            if (line.startsWith('#if ') && !line.startsWith('#ifndef') && !line.startsWith('#ifdef')) {
                const conditionMatch = line.match(/#if\s+(.+)/);
                if (conditionMatch) {
                    const conditionStr = conditionMatch[1].trim();
                    const result = this.evaluateCondition(conditionStr);
                    conditionalStack.push({ type: 'if', condition: result, taken: result });
                    if (!result) {
                        skipUntilEndif++;
                        this.log(`   ‚è≠Ô∏è  Skipping #if block (condition false):`, conditionStr);
                    } else {
                        this.log(`   ‚úÖ Entering #if block (condition true):`, conditionStr);
                    }
                }
                continue;
            }
            
            // Handle #elif - alternative condition
            if (line.startsWith('#elif')) {
                if (conditionalStack.length > 0) {
                    const currentBlock = conditionalStack[conditionalStack.length - 1];
                    
                    // If we already took a branch, skip this one
                    if (currentBlock.taken) {
                        if (skipUntilEndif === 0) skipUntilEndif = 1;
                        this.log(`   ‚è≠Ô∏è  Skipping #elif (previous branch taken)`);
                        continue;
                    }
                    
                    // Evaluate elif condition
                    const conditionMatch = line.match(/#elif\s+(.+)/);
                    if (conditionMatch) {
                        const conditionStr = conditionMatch[1].trim();
                        const result = this.evaluateCondition(conditionStr);
                        
                        if (result) {
                            // This elif branch is true - start taking code
                            if (skipUntilEndif > 0) skipUntilEndif--;
                            currentBlock.taken = true;
                            this.log(`   ‚úÖ Entering #elif block (condition true):`, conditionStr);
                        } else {
                            // This elif is false - keep skipping
                            if (skipUntilEndif === 0) skipUntilEndif = 1;
                            this.log(`   ‚è≠Ô∏è  Skipping #elif block (condition false):`, conditionStr);
                        }
                    }
                }
                continue;
            }
            
            // Handle #else - default branch
            if (line.startsWith('#else')) {
                if (conditionalStack.length > 0) {
                    const currentBlock = conditionalStack[conditionalStack.length - 1];
                    
                    if (currentBlock.taken) {
                        // Previous branch was taken, skip else
                        if (skipUntilEndif === 0) skipUntilEndif = 1;
                        this.log(`   ‚è≠Ô∏è  Skipping #else (previous branch taken)`);
                    } else {
                        // No previous branch taken, take else
                        if (skipUntilEndif > 0) skipUntilEndif--;
                        currentBlock.taken = true;
                        this.log(`   ‚úÖ Entering #else block`);
                    }
                }
                continue;
            }
            
            // Handle #endif - close conditional block
            if (line.startsWith('#endif')) {
                if (skipUntilEndif > 0) {
                    skipUntilEndif--;
                }
                if (conditionalStack.length > 0) {
                    conditionalStack.pop();
                }
                continue;
            }
            
            // Skip lines if we're in a false conditional block
            if (skipUntilEndif > 0) {
                continue;
            }
            
            // Parse #define statements
            if (line.startsWith('#define')) {
                // Also store numeric values for variable substitution
                const valueMatch = line.match(/#define\s+(\w+)\s+([\d.]+)\s*(?:\/\/.*)?$/);
                if (valueMatch) {
                    this.variables[valueMatch[1]] = valueMatch[2];
                    this.log(`   üì¶ Variable stored (from active branch):`, valueMatch[1], '=', valueMatch[2]);
                }
                
                this.parseDefineLine(line, config);
            }
        }
        
        this.log('üîç Final bedLeveling config:', config.bedLeveling);
        
        // Validate and add warnings
        this.validateConfig(config);
        
        return config;
    },
    
    /**
     * Evaluate a conditional expression (#if, #elif)
     * Handles: comparisons, ENABLED(), DISABLED(), logical operators
     */
    evaluateCondition(conditionStr) {
        // Handle ENABLED(NAME) - check if NAME is in globalConditionals
        conditionStr = conditionStr.replace(/ENABLED\((\w+)\)/g, (match, name) => {
            return this.globalConditionals.has(name) ? 'true' : 'false';
        });
        
        // Handle DISABLED(NAME) - check if NAME is NOT in globalConditionals
        conditionStr = conditionStr.replace(/DISABLED\((\w+)\)/g, (match, name) => {
            return !this.globalConditionals.has(name) ? 'true' : 'false';
        });
        
        // Replace variable names with their values
        conditionStr = conditionStr.replace(/\b([A-Z_][A-Z0-9_]*)\b/g, (match, varName) => {
            // Check if it's a known variable
            if (this.variables && this.variables[varName] !== undefined) {
                return this.variables[varName];
            }
            // Check basic config for bed size
            if (varName === 'X_BED_SIZE' && this.variables['X_BED_SIZE']) {
                return this.variables['X_BED_SIZE'];
            }
            if (varName === 'Y_BED_SIZE' && this.variables['Y_BED_SIZE']) {
                return this.variables['Y_BED_SIZE'];
            }
            // If not found, assume it's undefined (false)
            return '0';
        });
        
        // Handle logical operators (convert to JavaScript)
        conditionStr = conditionStr.replace(/&&/g, '&&');
        conditionStr = conditionStr.replace(/\|\|/g, '||');
        conditionStr = conditionStr.replace(/!/g, '!');
        
        // Try to evaluate the expression safely
        try {
            // Use Function constructor to evaluate (safer than eval)
            const result = new Function(`return ${conditionStr}`)();
            this.log(`   üìä Condition "${conditionStr}" evaluated to:`, result);
            return !!result; // Convert to boolean
        } catch (error) {
            this.log(`   ‚ö†Ô∏è  Could not evaluate condition "${conditionStr}":`, error.message);
            return false; // Default to false if evaluation fails
        }
    },
    
    /**
     * Check if a define is a global conditional
     * These persist across all config files
     */
    isGlobalConditional(defineName) {
        const globalPatterns = [
            // Printer models
            /^ENDER\d+/,
            /^CR10/,
            /^CHIRON/,
            /^AQUILA/,
            
            // Probe types
            /^BLTOUCH/,
            /^EZABL/,
            /^CUSTOM_PROBE/,
            /.*_OEM$/,  // Probe mounts
            /.*_MOUNT$/,
            
            // Major features
            /^LINEAR_ADVANCE/,
            /^INPUT_SHAPING/,
            /^EZOUT_ENABLE/,
            /^MANUAL_MESH_LEVELING/,
            /^ABL_/,
            /^V42X_TMC/,
            /^EZNEO/,
            
            // Hardware variants
            /^ENDER\d+_LDO/,
            /^SPRITE_EXTRUDER/,
            /^XTENDER_/
        ];
        
        return globalPatterns.some(pattern => pattern.test(defineName));
    },
    
    /**
     * Parse a single #define line using field mapping
     * 
     * ‚ö†Ô∏è TODO: Add fallback for unmapped fields
     * If a #define is not found in the mapping, we silently skip it.
     * Consider adding a "unknown" or "unmapped" section to capture these
     * so users can identify missing fields in the mapping.
     */
    parseDefineLine(line, config) {
        // Extract the define name and value
        const match = line.match(/#define\s+(\w+)(?:\s+(.+))?/);
        if (!match) return;
        
        const [, defineName, value] = match;
        const cleanValue = value ? value.split('//')[0].trim() : true;
        
        // Search through field mapping for this define
        for (const [category, fields] of Object.entries(this.fieldMapping)) {
            // Skip metadata fields
            if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'warnings') {
                continue;
            }
            
            for (const [fieldName, fieldSpec] of Object.entries(fields)) {
                // Skip non-field entries
                if (typeof fieldSpec !== 'object' || !fieldSpec.mapsFrom) {
                    continue;
                }
                
                // Check if this define matches any mapsFrom value
                const mapsFrom = Array.isArray(fieldSpec.mapsFrom) ? fieldSpec.mapsFrom : [fieldSpec.mapsFrom];
                
                // Handle wildcard matches (e.g., "LCD_*", "DISPLAY_*")
                let matched = false;
                for (const mapPattern of mapsFrom) {
                    if (mapPattern.includes('*')) {
                        // Wildcard pattern - convert to regex
                        const regex = new RegExp('^' + mapPattern.replace(/\*/g, '.*') + '$');
                        if (regex.test(defineName)) {
                            matched = true;
                            break;
                        }
                    } else if (mapPattern === defineName) {
                        // Exact match
                        matched = true;
                        break;
                    }
                }
                
                if (matched) {
                    // Check conditional dependencies before parsing
                    if (fieldSpec.conditionalOn) {
                        const conditions = Array.isArray(fieldSpec.conditionalOn) ? fieldSpec.conditionalOn : [fieldSpec.conditionalOn];
                        const hasActiveParent = conditions.some(cond => this.globalConditionals.has(cond));
                        
                        if (!hasActiveParent) {
                            this.log(`   ‚è≠Ô∏è  Skipped ${defineName} (conditionalOn: ${conditions.join(' OR ')}) - parent(s) not active`);
                            return; // Skip this field - parent condition not met
                        }
                    }
                    
                    // Extract and store the value based on field type
                    const extractedValue = this.extractValue(cleanValue, fieldSpec.type, fieldSpec);
                    
                    // Store in correct category and handle nested structures
                    this.storeValue(config, category, fieldName, extractedValue, fieldSpec);
                    
                    this.log(`   ‚úÖ Mapped ${defineName} ‚Üí ${category}.${fieldName} =`, extractedValue);
                    return; // Stop after first match
                }
            }
        }
        
        // TODO: If we reach here, the define was not found in mapping
        // Consider logging or storing unknown defines for debugging
        // this.log(`   ‚ö†Ô∏è Unmapped define: ${defineName} = ${cleanValue}`);
    },
    
    /**
     * Extract value based on field type
     * Handles variable substitution - returns expressions as-is
     */
    extractValue(rawValue, type, fieldSpec) {
        // Ensure rawValue is a string for processing
        if (typeof rawValue !== 'string') {
            rawValue = String(rawValue);
        }
        
        // Check if rawValue is a variable reference (not a number, not quoted, not an array, not an expression)
        if (!rawValue.match(/^[\d.-]+$/) &&      // Not a simple number
            !rawValue.match(/^["']/) &&           // Not a quoted string
            !rawValue.match(/^\{/) &&             // Not an array
            !rawValue.match(/[\(\)\*\/\+\-]/) && // Not a mathematical expression
            this.variables && this.variables[rawValue]) {
            
            this.log(`üîÑ TH3D Parser: Resolving variable ${rawValue} = ${this.variables[rawValue]}`);
            rawValue = this.variables[rawValue];
        }
        
        // For expressions like (200*60), store as-is for user configuration
        if (rawValue.match(/[\(\)\*\/]/)) {
            this.log(`üìê TH3D Parser: Storing expression as-is: ${rawValue}`);
            return rawValue; // Return the expression string for user to configure
        }
        
        switch (type) {
            case 'string':
                return this.extractString(rawValue);
            
            case 'integer':
                const intVal = parseInt(rawValue);
                return isNaN(intVal) ? rawValue : intVal; // Return original if can't parse
            
            case 'float':
                const floatVal = parseFloat(rawValue);
                return isNaN(floatVal) ? rawValue : floatVal; // Return original if can't parse
            
            case 'boolean':
                // For defines, presence = true
                return rawValue === true || rawValue === 'true' || rawValue === '1';
            
            case 'array':
                return this.extractArray(rawValue);
            
            default:
                // Unknown type, return as-is
                return rawValue;
        }
    },
    
    /**
     * Store value in config object (handles nested structures and array mapping)
     * 
     * ‚úÖ FIXED: Now handles array field mapping
     * When mapsFrom contains array notation like "DEFAULT_AXIS_STEPS_PER_UNIT[0]",
     * the parser extracts the array once and maps elements to individual fields:
     *   - array[0] ‚Üí stepsPerMM.x
     *   - array[1] ‚Üí stepsPerMM.y
     *   - array[2] ‚Üí stepsPerMM.z
     *   - array[3] ‚Üí stepsPerMM.e
     */
    storeValue(config, category, fieldName, value, fieldSpec) {
        // Handle array index extraction for fields like DEFAULT_AXIS_STEPS_PER_UNIT[0]
        const mapsFrom = Array.isArray(fieldSpec.mapsFrom) ? fieldSpec.mapsFrom[0] : fieldSpec.mapsFrom;
        const arrayMatch = mapsFrom.match(/^(.+)\[(\d+)\]$/);
        
        if (arrayMatch && Array.isArray(value)) {
            // This is an array field with index notation
            const [, arrayName, indexStr] = arrayMatch;
            const index = parseInt(indexStr);
            
            this.log(`   üî¢ Array field detected: ${arrayName}[${index}] ‚Üí extracting element ${index}`);
            
            // Extract the specific array element
            value = value[index];
            
            // Convert to appropriate type
            if (fieldSpec.type === 'float') {
                value = parseFloat(value);
            } else if (fieldSpec.type === 'integer') {
                value = parseInt(value);
            }
        }
        
        // Handle nested field names (e.g., "motion.stepsPerMM.x")
        if (fieldName.includes('.')) {
            const parts = fieldName.split('.');
            let current = config[category];
            
            for (let i = 0; i < parts.length - 1; i++) {
                if (!current[parts[i]]) {
                    current[parts[i]] = {};
                }
                current = current[parts[i]];
            }
            
            current[parts[parts.length - 1]] = value;
        } else {
            // Simple field
            if (!config[category]) {
                config[category] = {};
            }
            config[category][fieldName] = value;
        }
        
        // Special handling for specific fields
        
        // Store USER_PRINTER_NAME for variable resolution
        if (fieldName === 'machineName' && category === 'basic') {
            config.basic.userPrinterNameValue = value;
        }
        
        // Handle EZABL_POINTS variable storage
        if (fieldName === 'gridPointsX' && value && !isNaN(value)) {
            this.variables['EZABL_POINTS'] = value;
        }
    },
    
    /**
     * Extract string value from quotes
     */
    extractString(value) {
        const match = value.match(/["'](.+?)["']/);
        return match ? match[1] : value;
    },
    
    /**
     * Extract array values from { x, y, z, ... }
     * Handles variable substitution (e.g., CUSTOM_ESTEPS_VALUE)
     */
    extractArray(value) {
        const match = value.match(/\{(.+?)\}/);
        if (!match) return [];
        return match[1].split(',').map(v => {
            v = v.trim();
            // Check if it's a variable reference
            if (this.variables && this.variables[v]) {
                this.log(`üîÑ TH3D Parser: Substituting ${v} = ${this.variables[v]}`);
                return this.variables[v];
            }
            return v;
        });
    },
    
    /**
     * Validate configuration and add warnings
     */
    validateConfig(config) {
        // Use validation rules from field mapping
        for (const [category, fields] of Object.entries(this.fieldMapping)) {
            // Skip metadata
            if (category.startsWith('$') || category === 'description' || category === 'lastUpdated' || category === 'version' || category === 'warnings') {
                continue;
            }
            
            for (const [fieldName, fieldSpec] of Object.entries(fields)) {
                if (!fieldSpec.validation) continue;
                
                const validation = fieldSpec.validation;
                const value = config[category]?.[fieldName];
                
                // Required field check
                if (fieldSpec.required && !value) {
                    config.warnings.push({
                        level: validation.errorLevel || 'error',
                        message: `Missing required field: ${fieldName} (${fieldSpec.mapsFrom.join(', ')})`
                    });
                }
                
                // Must be true check
                if (validation.mustBeTrue && !value) {
                    config.warnings.push({
                        level: validation.errorLevel || 'error',
                        message: fieldSpec.th3dNotes || `${fieldName} should be enabled for safety`
                    });
                }
                
                // Range checks
                if (value !== undefined && value !== null) {
                    if (validation.min !== undefined && value < validation.min) {
                        config.warnings.push({
                            level: 'warning',
                            message: `${fieldName} (${value}) is below minimum (${validation.min})`
                        });
                    }
                    
                    if (validation.max !== undefined && value > validation.max) {
                        config.warnings.push({
                            level: 'warning',
                            message: `${fieldName} (${value}) is above maximum (${validation.max})`
                        });
                    }
                    
                    // Warning if outside range
                    if (validation.warningIfOutside) {
                        if ((validation.min && value < validation.min) || (validation.max && value > validation.max)) {
                            config.warnings.push({
                                level: 'warning',
                                message: `${fieldName} (${value}) is outside typical range (${validation.min}-${validation.max})`
                            });
                        }
                    }
                }
            }
        }
    },
    
    /**
     * Parse multiple TH3D configuration files and merge into one config
     * @param {object} files - Object with file contents: { config: "", configAdv: "", configBackend: "", configSpeed: "" }
     * @returns {object} Merged parsed configuration object
     */
    async parseMultipleFiles(files) {
        // Ensure mapping is loaded
        await this.loadFieldMapping();
        
        this.log('üìö TH3D Parser: Parsing multiple config files');
        
        // Parse each file in order (later files can reference earlier variables)
        const configs = [];
        
        if (files.config) {
            this.log('   üìÑ Parsing Configuration.h...');
            const cfg = await this.parseConfigFile(files.config);
            configs.push(cfg);
        }
        
        if (files.configAdv) {
            this.log('   üìÑ Parsing Configuration_adv.h...');
            const cfg = await this.parseConfigFile(files.configAdv);
            configs.push(cfg);
        }
        
        if (files.configBackend) {
            this.log('   üìÑ Parsing Configuration_backend.h...');
            const cfg = await this.parseConfigFile(files.configBackend);
            configs.push(cfg);
        }
        
        if (files.configSpeed) {
            this.log('   üìÑ Parsing Configuration_speed.h...');
            const cfg = await this.parseConfigFile(files.configSpeed);
            configs.push(cfg);
        }
        
        // Merge all configs (later files override earlier)
        const merged = this.mergeConfigs(configs);
        
        this.log('‚úÖ TH3D Parser: All files parsed and merged');
        
        return merged;
    },
    
    /**
     * Merge multiple config objects
     * Later configs override earlier ones for the same fields
     */
    mergeConfigs(configs) {
        const merged = {
            basic: {},
            hardware: {},
            temperature: {},
            motion: {},
            probe: {},
            bedLeveling: {},
            advanced: {},
            safety: {},
            communication: {},
            serial: {},
            tmc: {},
            thermal: {},
            lcd: {},
            speed: {},
            backend: {},
            warnings: []
        };
        
        // Merge each config
        for (const config of configs) {
            for (const [category, fields] of Object.entries(config)) {
                if (category === 'warnings') {
                    // Accumulate warnings from all files
                    merged.warnings.push(...fields);
                    continue;
                }
                
                // Initialize category if needed
                if (!merged[category]) {
                    merged[category] = {};
                }
                
                // Merge fields (deep merge for nested objects)
                this.deepMerge(merged[category], fields);
            }
        }
        
        return merged;
    },
    
    /**
     * Deep merge two objects (later values override earlier)
     */
    deepMerge(target, source) {
        for (const [key, value] of Object.entries(source)) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                // Nested object - recurse
                if (!target[key]) {
                    target[key] = {};
                }
                this.deepMerge(target[key], value);
            } else {
                // Simple value or array - override
                target[key] = value;
            }
        }
    },
    
    /**
     * Alias for parseConfigFile (for compatibility)
     */
    async parseConfigurationH(content) {
        return await this.parseConfigFile(content);
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.TH3DConfigParser = TH3DConfigParser;
}
