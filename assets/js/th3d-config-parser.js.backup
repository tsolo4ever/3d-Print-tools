/* ============================================
   TH3D Configuration.h Parser
   Parse TH3D Unified Firmware Configuration files
   Optimized for TH3D-specific naming conventions
   ============================================ */

const TH3DConfigParser = {
    
    /**
     * Parse TH3D Configuration.h file content
     * @param {string} content - File content as text
     * @returns {object} Parsed configuration object
     */
    parseConfigFile(content) {
        const config = {
            basic: {},
            hardware: {},
            temperature: {},
            motion: {},
            probe: {},
            bedLeveling: {},
            advanced: {},
            safety: {},
            warnings: []
        };
        
        // Store defined variables for substitution (preserve across multiple file parses)
        if (!this.variables) {
            this.variables = {};
        }
        
        const lines = content.split('\n');
        
        console.log('üîç TH3D Parser: Starting parse of', lines.length, 'lines');
        
        // First pass: collect simple variable definitions
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith('#define')) {
                const match = line.match(/#define\s+(\w+)\s+([\d.]+)$/);
                if (match) {
                    this.variables[match[1]] = match[2];
                    console.log('   üìù Stored variable:', match[1], '=', match[2]);
                }
            }
        }
        
        console.log('üîç Variables collected:', Object.keys(this.variables).length);
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines and pure comments
            if (!line || line.startsWith('//') || line.startsWith('/*') || line.startsWith('*')) {
                continue;
            }
            
            // Parse #define statements
            if (line.startsWith('#define')) {
                this.parseDefineLine(line, config);
            }
        }
        
        console.log('üîç Final bedLeveling config:', config.bedLeveling);
        
        // Validate and add warnings
        this.validateConfig(config);
        
        return config;
    },
    
    /**
     * Parse a single #define line (TH3D specific)
     */
    parseDefineLine(line, config) {
        // Extract the define name and value
        const match = line.match(/#define\s+(\w+)(?:\s+(.+))?/);
        if (!match) return;
        
        const [, name, value] = match;
        const cleanValue = value ? value.split('//')[0].trim() : true;
        
        // === TH3D SPECIFIC FIELDS ===
        
        // TH3D Firmware Version
        if (name === 'UNIFIED_VERSION') {
            config.basic.firmwareVersion = this.extractString(cleanValue);
        }
        
        // TH3D Distribution Date
        else if (name === 'STRING_DISTRIBUTION_DATE') {
            config.basic.distributionDate = this.extractString(cleanValue);
        }
        
        // === BED TYPE (TH3D Specific) ===
        else if (name === 'AC_BED') {
            config.temperature.bedType = 'AC';
        }
        
        // Machine Name (TH3D uses USER_PRINTER_NAME)
        else if (name === 'USER_PRINTER_NAME') {
            const extracted = this.extractString(cleanValue);
            console.log('üîç TH3D Parser found USER_PRINTER_NAME!');
            console.log('   Raw value:', cleanValue);
            console.log('   Extracted:', extracted);
            config.basic.machineName = extracted;
            // Store for variable resolution
            config.basic.userPrinterNameValue = extracted;
        }
        
        // Also support standard Marlin field as fallback
        // BUT skip if it's a variable reference (e.g., "USER_PRINTER_NAME" without quotes)
        else if (name === 'CUSTOM_MACHINE_NAME') {
            const extracted = this.extractString(cleanValue);
            // If it's a variable reference (no quotes found, returns the raw value)
            if (extracted === cleanValue && cleanValue === 'USER_PRINTER_NAME') {
                // It's a variable reference - use the stored value if available
                if (config.basic.userPrinterNameValue) {
                    config.basic.machineName = config.basic.userPrinterNameValue;
                }
                // Don't overwrite with the variable name
            } else if (!config.basic.machineName) {
                // It's a real string value, use it
                config.basic.machineName = extracted;
            }
        }
        
        // === BASIC INFO ===
        else if (name === 'MACHINE_UUID') {
            config.basic.uuid = this.extractString(cleanValue);
        } else if (name === 'STRING_CONFIG_H_AUTHOR') {
            config.basic.author = this.extractString(cleanValue);
        } else if (name === 'MOTHERBOARD') {
            config.basic.motherboard = cleanValue;
        } else if (name === 'SERIAL_PORT') {
            config.basic.serialPort = parseInt(cleanValue);
        } else if (name === 'BAUDRATE') {
            config.basic.baudRate = parseInt(cleanValue);
        }
        
        // === STEPPER DRIVERS ===
        else if (name === 'X_DRIVER_TYPE') {
            config.hardware.driverX = cleanValue;
        } else if (name === 'Y_DRIVER_TYPE') {
            config.hardware.driverY = cleanValue;
        } else if (name === 'Z_DRIVER_TYPE') {
            config.hardware.driverZ = cleanValue;
        } else if (name === 'E0_DRIVER_TYPE') {
            config.hardware.driverE0 = cleanValue;
        }
        
        // === THERMISTORS ===
        else if (name === 'TEMP_SENSOR_0') {
            config.hardware.thermistorHotend = parseInt(cleanValue);
        } else if (name === 'TEMP_SENSOR_BED') {
            config.hardware.thermistorBed = parseInt(cleanValue);
        }
        
        // === TEMPERATURE LIMITS ===
        else if (name === 'HEATER_0_MAXTEMP') {
            config.temperature.hotendMaxTemp = parseInt(cleanValue);
        } else if (name === 'BED_MAXTEMP') {
            config.temperature.bedMaxTemp = parseInt(cleanValue);
        }
        
        // === PID ===
        else if (name === 'PIDTEMP') {
            config.temperature.pidHotendEnabled = true;
        } else if (name === 'DEFAULT_Kp') {
            config.temperature.pidHotendP = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_Ki') {
            config.temperature.pidHotendI = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_Kd') {
            config.temperature.pidHotendD = parseFloat(cleanValue);
        } else if (name === 'PIDTEMPBED') {
            config.temperature.pidBedEnabled = true;
        } else if (name === 'DEFAULT_bedKp') {
            config.temperature.pidBedP = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_bedKi') {
            config.temperature.pidBedI = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_bedKd') {
            config.temperature.pidBedD = parseFloat(cleanValue);
        }
        
        // === MOTION ===
        else if (name === 'DEFAULT_AXIS_STEPS_PER_UNIT') {
            const steps = this.extractArray(cleanValue);
            if (steps.length >= 4) {
                config.motion.stepsPerMM = {
                    x: parseFloat(steps[0]),
                    y: parseFloat(steps[1]),
                    z: parseFloat(steps[2]),
                    e: parseFloat(steps[3])
                };
            }
        } else if (name === 'DEFAULT_MAX_FEEDRATE') {
            const feedrates = this.extractArray(cleanValue);
            if (feedrates.length >= 4) {
                config.motion.maxFeedrate = {
                    x: parseFloat(feedrates[0]),
                    y: parseFloat(feedrates[1]),
                    z: parseFloat(feedrates[2]),
                    e: parseFloat(feedrates[3])
                };
            }
        } else if (name === 'DEFAULT_MAX_ACCELERATION') {
            const accels = this.extractArray(cleanValue);
            if (accels.length >= 4) {
                config.motion.maxAcceleration = {
                    x: parseFloat(accels[0]),
                    y: parseFloat(accels[1]),
                    z: parseFloat(accels[2]),
                    e: parseFloat(accels[3])
                };
            }
        } else if (name === 'DEFAULT_ACCELERATION') {
            config.motion.defaultAcceleration = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_RETRACT_ACCELERATION') {
            config.motion.retractAcceleration = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_TRAVEL_ACCELERATION') {
            config.motion.travelAcceleration = parseFloat(cleanValue);
        }
        
        // === JERK ===
        else if (name === 'CLASSIC_JERK') {
            config.motion.classicJerk = true;
        } else if (name === 'DEFAULT_XJERK') {
            config.motion.jerkX = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_YJERK') {
            config.motion.jerkY = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_ZJERK') {
            config.motion.jerkZ = parseFloat(cleanValue);
        } else if (name === 'DEFAULT_EJERK') {
            config.motion.jerkE = parseFloat(cleanValue);
        }
        
        // === PROBE (TH3D specific options) ===
        else if (name === 'EZABL_ENABLE') {
            config.probe.type = 'EZABL'; // TH3D's own probe
        } else if (name === 'BLTOUCH') {
            config.probe.type = 'BLTouch';
        } else if (name === 'NOZZLE_TO_PROBE_OFFSET') {
            const offsets = this.extractArray(cleanValue);
            if (offsets.length >= 3) {
                config.probe.offset = {
                    x: parseFloat(offsets[0]),
                    y: parseFloat(offsets[1]),
                    z: parseFloat(offsets[2])
                };
            }
        }
        
        // === BED LEVELING (TH3D Simplified) ===
        // TH3D uses simple ABL_UBL and ABL_BILINEAR
        else if (name === 'ABL_UBL') {
            config.bedLeveling.type = 'UBL';
        } else if (name === 'ABL_BILINEAR') {
            config.bedLeveling.type = 'BILINEAR';
        }
        // Fallback to standard Marlin naming
        else if (name === 'AUTO_BED_LEVELING_BILINEAR') {
            config.bedLeveling.type = 'BILINEAR';
        } else if (name === 'AUTO_BED_LEVELING_UBL') {
            config.bedLeveling.type = 'UBL';
        } else if (name === 'AUTO_BED_LEVELING_3POINT') {
            config.bedLeveling.type = '3POINT';
        } else if (name === 'AUTO_BED_LEVELING_LINEAR') {
            config.bedLeveling.type = 'LINEAR';
        } else if (name === 'MESH_BED_LEVELING') {
            config.bedLeveling.type = 'MESH';
        }
        
        // TH3D-specific grid points (EZABL_POINTS)
        // Only set if not already defined (to avoid fallback values overwriting user settings)
        else if (name === 'EZABL_POINTS') {
            console.log('üîç EZABL_POINTS encountered:');
            console.log('   cleanValue:', cleanValue);
            console.log('   current gridPointsX:', config.bedLeveling.gridPointsX);
            console.log('   isNaN check:', isNaN(config.bedLeveling.gridPointsX));
            
            // Only set if not already a valid number
            if (isNaN(config.bedLeveling.gridPointsX)) {
                const points = parseInt(cleanValue);
                console.log('   parsed points:', points);
                
                if (!isNaN(points)) {
                    config.bedLeveling.gridPointsX = points;
                    config.bedLeveling.gridPointsY = points;
                    // Store for variable substitution
                    this.variables['EZABL_POINTS'] = points;
                    console.log('   ‚úÖ Set EZABL_POINTS to:', points);
                } else {
                    console.log('   ‚ö†Ô∏è Failed to parse EZABL_POINTS, got NaN from:', cleanValue);
                }
            } else {
                console.log('   ‚è≠Ô∏è Skipping - already have valid value:', config.bedLeveling.gridPointsX);
            }
        }
        
        // UBL mesh points (can reference EZABL_POINTS)
        else if (name === 'UBL_MESH_X_POINTS') {
            console.log('üîç UBL_MESH_X_POINTS found! cleanValue:', cleanValue);
            console.log('   current gridPointsX:', config.bedLeveling.gridPointsX);
            
            // Check if it's a variable reference
            if (cleanValue === 'EZABL_POINTS' && this.variables['EZABL_POINTS']) {
                config.bedLeveling.gridPointsX = this.variables['EZABL_POINTS'];
                console.log('   ‚úÖ Set from EZABL_POINTS variable:', this.variables['EZABL_POINTS']);
            } else {
                const parsed = parseInt(cleanValue);
                config.bedLeveling.gridPointsX = parsed;
                console.log('   ‚úÖ Set from parseInt:', parsed);
            }
        } else if (name === 'UBL_MESH_Y_POINTS') {
            console.log('üîç UBL_MESH_Y_POINTS found! cleanValue:', cleanValue);
            console.log('   current gridPointsY:', config.bedLeveling.gridPointsY);
            
            // Check if it's a variable reference
            if (cleanValue === 'UBL_MESH_X_POINTS' && config.bedLeveling.gridPointsX) {
                config.bedLeveling.gridPointsY = config.bedLeveling.gridPointsX;
                console.log('   ‚úÖ Set from UBL_MESH_X_POINTS:', config.bedLeveling.gridPointsX);
            } else if (cleanValue === 'EZABL_POINTS' && this.variables['EZABL_POINTS']) {
                config.bedLeveling.gridPointsY = this.variables['EZABL_POINTS'];
                console.log('   ‚úÖ Set from EZABL_POINTS variable:', this.variables['EZABL_POINTS']);
            } else {
                const parsed = parseInt(cleanValue);
                config.bedLeveling.gridPointsY = parsed;
                console.log('   ‚úÖ Set from parseInt:', parsed);
            }
        }
        
        // Standard Marlin grid points (fallback)
        else if (name === 'GRID_MAX_POINTS_X') {
            console.log('üîç GRID_MAX_POINTS_X found! cleanValue:', cleanValue);
            
            // Check if it's a variable reference (e.g., "EZABL_POINTS")
            if (this.variables[cleanValue]) {
                config.bedLeveling.gridPointsX = parseInt(this.variables[cleanValue]);
                console.log('   ‚úÖ Resolved from variable:', cleanValue, '=', this.variables[cleanValue]);
            } else {
                const parsed = parseInt(cleanValue);
                config.bedLeveling.gridPointsX = parsed;
                console.log('   ‚úÖ Parsed directly:', parsed);
            }
        } else if (name === 'GRID_MAX_POINTS_Y') {
            console.log('üîç GRID_MAX_POINTS_Y found! cleanValue:', cleanValue);
            
            // Check if it's a variable reference (e.g., "GRID_MAX_POINTS_X" or "EZABL_POINTS")
            if (cleanValue === 'GRID_MAX_POINTS_X' && config.bedLeveling.gridPointsX) {
                config.bedLeveling.gridPointsY = config.bedLeveling.gridPointsX;
                console.log('   ‚úÖ Set from GRID_MAX_POINTS_X:', config.bedLeveling.gridPointsX);
            } else if (this.variables[cleanValue]) {
                config.bedLeveling.gridPointsY = parseInt(this.variables[cleanValue]);
                console.log('   ‚úÖ Resolved from variable:', cleanValue, '=', this.variables[cleanValue]);
            } else {
                const parsed = parseInt(cleanValue);
                config.bedLeveling.gridPointsY = parsed;
                console.log('   ‚úÖ Parsed directly:', parsed);
            }
        }
        
        // === BED SIZE ===
        else if (name === 'X_BED_SIZE') {
            config.basic.bedSizeX = parseInt(cleanValue);
        } else if (name === 'Y_BED_SIZE') {
            config.basic.bedSizeY = parseInt(cleanValue);
        } else if (name === 'Z_MAX_POS') {
            config.basic.zMaxPos = parseInt(cleanValue);
        }
        
        // === ADVANCED FEATURES ===
        // TH3D uses LINEAR_ADVANCE (not LIN_ADVANCE)
        else if (name === 'LINEAR_ADVANCE') {
            if (!config.advanced.linearAdvance) config.advanced.linearAdvance = {};
            config.advanced.linearAdvance.enabled = true;
        } else if (name === 'LINEAR_ADVANCE_K') {
            if (!config.advanced.linearAdvance) config.advanced.linearAdvance = {};
            config.advanced.linearAdvance.k = parseFloat(cleanValue);
        }
        // Fallback to standard Marlin naming
        else if (name === 'LIN_ADVANCE') {
            if (!config.advanced.linearAdvance) config.advanced.linearAdvance = {};
            config.advanced.linearAdvance.enabled = true;
        } else if (name === 'LIN_ADVANCE_K') {
            if (!config.advanced.linearAdvance) config.advanced.linearAdvance = {};
            config.advanced.linearAdvance.k = parseFloat(cleanValue);
        }
        
        // === INPUT SHAPING (TH3D Simplified) ===
        else if (name === 'INPUT_SHAPING') {
            if (!config.advanced.inputShaping) config.advanced.inputShaping = {};
            config.advanced.inputShaping.enabled = true;
        } else if (name === 'INPUT_SHAPING_FREQ_X') {
            if (!config.advanced.inputShaping) config.advanced.inputShaping = {};
            config.advanced.inputShaping.freqX = parseFloat(cleanValue);
        } else if (name === 'INPUT_SHAPING_FREQ_Y') {
            if (!config.advanced.inputShaping) config.advanced.inputShaping = {};
            config.advanced.inputShaping.freqY = parseFloat(cleanValue);
        } else if (name === 'INPUT_SHAPING_DAMPING_X') {
            if (!config.advanced.inputShaping) config.advanced.inputShaping = {};
            config.advanced.inputShaping.dampingX = parseFloat(cleanValue);
        } else if (name === 'INPUT_SHAPING_DAMPING_Y') {
            if (!config.advanced.inputShaping) config.advanced.inputShaping = {};
            config.advanced.inputShaping.dampingY = parseFloat(cleanValue);
        }
        
        // Arc Support
        else if (name === 'ARC_SUPPORT') {
            config.advanced.arcSupport = true;
        }
        
        // === SAFETY ===
        else if (name === 'THERMAL_PROTECTION_HOTENDS') {
            config.safety.thermalProtectionHotend = true;
        } else if (name === 'THERMAL_PROTECTION_BED') {
            config.safety.thermalProtectionBed = true;
        } else if (name === 'FILAMENT_RUNOUT_SENSOR') {
            config.safety.filamentSensor = true;
        }
        
        // === TH3D SPECIFIC FEATURES ===
        else if (name === 'TH3D_RGB_ENABLE') {
            config.advanced.th3dRGB = true;
        } else if (name === 'POWER_LOSS_RECOVERY') {
            config.advanced.powerLossRecovery = true;
        }
    },
    
    /**
     * Extract string value from quotes
     */
    extractString(value) {
        const match = value.match(/["'](.+?)["']/);
        return match ? match[1] : value;
    },
    
    /**
     * Extract array values from { x, y, z, ... }
     * Handles variable substitution (e.g., CUSTOM_ESTEPS_VALUE)
     */
    extractArray(value) {
        const match = value.match(/\{(.+?)\}/);
        if (!match) return [];
        return match[1].split(',').map(v => {
            v = v.trim();
            // Check if it's a variable reference
            if (this.variables && this.variables[v]) {
                console.log(`üîÑ TH3D Parser: Substituting ${v} = ${this.variables[v]}`);
                return this.variables[v];
            }
            return v;
        });
    },
    
    /**
     * Validate configuration and add warnings
     */
    validateConfig(config) {
        // Check for missing critical settings
        if (!config.basic.motherboard) {
            config.warnings.push({
                level: 'error',
                message: 'No motherboard defined (MOTHERBOARD)'
            });
        }
        
        if (!config.motion.stepsPerMM) {
            config.warnings.push({
                level: 'warning',
                message: 'No steps per mm defined (DEFAULT_AXIS_STEPS_PER_UNIT)'
            });
        }
        
        // Check thermal protection
        if (!config.safety.thermalProtectionHotend) {
            config.warnings.push({
                level: 'error',
                message: 'Thermal protection for hotend is DISABLED! This is dangerous!'
            });
        }
    },
    
    /**
     * Alias for parseConfigFile (for compatibility)
     */
    parseConfigurationH(content) {
        return this.parseConfigFile(content);
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.TH3DConfigParser = TH3DConfigParser;
}
